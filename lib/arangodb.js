// Generated by CoffeeScript 1.10.0
var ArangoDBConnector, Connector, GeoPoint, _, _fieldIncluded, arangojs, async, debug, generateConnObject, initializeDataSource, merge, qb, qbTypes, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

arangojs = require('arangojs');

qb = require('aqb');

qbTypes = require('aqb/types');

url = require('url');

merge = require('extend');

async = require('async');

_ = require('underscore');

Connector = require('loopback-connector').Connector;

GeoPoint = require('loopback-datasource-juggler').GeoPoint;

debug = require('debug')('loopback:connector:arango');

exports.generateConnObject = generateConnObject = function(settings) {
  var u;
  u = {};
  u.protocol = settings.protocol || 'http:';
  u.hostname = settings.hostname || settings.host || '127.0.0.1';
  u.port = settings.port || 8529;
  if (settings.username && settings.password) {
    u.auth = settings.username + ":" + settings.password;
  }
  settings.databaseName = settings.database || settings.db || 'test';
  settings.promise = settings.promise || false;
  return url.format(u);
};


/*
  Decide if field should be included
  @param {Object} fields
  @param {String} fieldName
  @returns {Boolean}
  @private
 */

_fieldIncluded = function(fields, fieldName) {
  var f, i, len;
  if (!fields) {
    return true;
  }
  if (Array.isArray(fields)) {
    return fields.indexOf(fieldName >= 0);
  }
  if (fields[fieldName]) {
    return true;
  }
  if (indexOf.call(fields, fieldName) >= 0 && !fields[fieldName]) {
    return false;
  }
  for (i = 0, len = fields.length; i < len; i++) {
    f = fields[i];
    return !fields[f];
  }
  return true;
};


/*
  Initialize the ArangoDB connector for the given data source
  @param dataSource [DataSource] The data source instance
  @param callback [Function] The callback function
 */

initializeDataSource = function(dataSource, callback) {
  var s;
  if (!arangojs) {
    return;
  }
  s = dataSource.settings;
  s.url = s.url || generateConnObject(s);
  dataSource.connector = new ArangoDBConnector(s, dataSource);
  if (callback != null) {
    return dataSource.connector.connect(callback);
  }
};

exports.initialize = initializeDataSource;


/*
  Loopback Arango Connector
  @extend Connector
 */

ArangoDBConnector = (function(superClass) {
  extend(ArangoDBConnector, superClass);


  /*
    The constructor for ArangoDB connector
    @constructor
    @param dataSource [Object] Object to connect this connector to a data source
    @option settings host [String] The host/ip address to connect with
    @option settings port [Number] The port to connect with
    @option settings database/db [String] The database to connect with
    @option settings headers [Object] Object with header to include in every request
    @param dataSource [DataSource] The data source instance
   */

  function ArangoDBConnector(settings, dataSource) {
    ArangoDBConnector.__super__.constructor.call(this, 'arangodb', settings);
    this.debug = dataSource.settings.debug || debug.enabled;
    this.dataSource = dataSource;
    this.qb = qb;
    this.returnVariable = 'result';
  }


  /*
    Connect to ArangoDB
    @param callback [Function] The callback function, called the with created connection
   */

  ArangoDBConnector.prototype.connect = function(callback) {
    if (this.debug) {
      debug("ArangoDB connection is called with settings: " + (JSON.stringify(this.settings)));
    }
    if (!this.db) {
      this.db = arangojs(this.settings);
      this.api = this.db.route('_api');
    }
    return process.nextTick(function() {
      return callback && callback(null, this.db);
    });
  };


  /*
    Get the types of this connector
    @return [Array<String>] The types of connectors this connector belongs to
   */

  ArangoDBConnector.prototype.getTypes = function() {
    return ['db', 'nosql', 'arangodb'];
  };


  /*
    The default Id type
    @return [Object] The class to build the Id Value with
   */

  ArangoDBConnector.prototype.getDefaultIdType = function() {
    return String;
  };


  /*
    Get the model class for a certain model name
    @param model [String] The model name to lookup
    @return [Object] The model class of this model
   */

  ArangoDBConnector.prototype.getModelClass = function(model) {
    return this._models[model];
  };


  /*
    Get the collection name for a certain model name
    @param model [String] The model name to lookup
    @return [Object] The collection name for this model
   */

  ArangoDBConnector.prototype.getCollectionName = function(model) {
    var modelClass;
    modelClass = this.getModelClass(model);
    if (modelClass.settings && modelClass.settings.arangodb) {
      model = modelClass.settings.arangodb.collection || model;
    }
    return model;
  };


  /*
    Set value of specific field into data object
    @param data {Object} The data object
    @param field {String} The name of field to set
    @param value {Any} The value to set
   */

  ArangoDBConnector.prototype._setFieldValue = function(data, field, value) {
    if (data) {
      return data[field] = value;
    }
  };


  /*
    Verify if the collection is an edge collection
    @param model [String] The model name to lookup
    @return [Boolean] Return true if collection is edge false otherwise
   */

  ArangoDBConnector.prototype._isEdge = function(model) {
    var modelClass;
    modelClass = this.getModelClass(model);
    return modelClass.settings && modelClass.settings.arangodb && modelClass.settings.arangodb.edge || false;
  };


  /*
    Get if the model has _id field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _id or false if model not has _id field
   */

  ArangoDBConnector.prototype._fullIdName = function(model) {
    var _id, key, prop, props;
    props = this.getModelClass(model).properties;
    for (key in props) {
      prop = props[key];
      _id = prop._id;
      if (!_id) {
        continue;
      }
      return key;
    }
    return false;
  };


  /*
    Finds calculated field names in a model
    @param model [String] The model name to lookup
    @return [Array|Boolean] Returns Array of field names or false if model has no calculated fields
   */

  ArangoDBConnector.prototype._calculatedProps = function(model) {
    var calculatedProps, key, prop, props;
    props = this.getModelClass(model).properties;
    for (key in props) {
      prop = props[key];
      if (!prop.arangodb || !prop.arangodb.aqlFormula) {
        continue;
      }
      if (!calculatedProps) {
        calculatedProps = {};
      }
      calculatedProps[key] = prop.arangodb.aqlFormula;
    }
    return calculatedProps || false;
  };


  /*
    Get if the model has _from field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _from or false if model not has _from field
   */

  ArangoDBConnector.prototype._fromName = function(model) {
    var _from, key, prop, props;
    props = this.getModelClass(model).properties;
    for (key in props) {
      prop = props[key];
      _from = prop._from;
      if (!_from) {
        continue;
      }
      return key;
    }
    return false;
  };


  /*
    Get if the model has _to field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _to or false if model not has _to field
   */

  ArangoDBConnector.prototype._toName = function(model) {
    var _to, key, prop, props;
    props = this.getModelClass(model).properties;
    for (key in props) {
      prop = props[key];
      _to = prop._to;
      if (!_to) {
        continue;
      }
      return key;
    }
    return false;
  };


  /*
    Access a ArangoDB collection by model name
    @param {String} model The model name
    @param callback [Function] The callback function
    @return {*}
   */

  ArangoDBConnector.prototype.getCollection = function(model) {
    var collection;
    if (!this.db) {
      throw new Error('ArangoDB connection is not established');
    }
    collection = ArangoDBConnector.collection;
    if (this._isEdge(model)) {
      collection = ArangoDBConnector.edgeCollection;
    }
    return this.db[collection](this.getCollectionName(model));
  };


  /*
    Converts the retrieved data from the database to JSON, based on the properties of a given model
    @param model [String] The model name to look up the properties
    @param data [Object] The data from DB
    @return [Object] The converted data as an JSON Object
   */

  ArangoDBConnector.prototype.fromDatabase = function(model, data) {
    var key, props, val;
    if (data == null) {
      return null;
    }
    props = this.getModelClass(model).properties;
    for (key in props) {
      val = props[key];
      if ((data[key] != null) && (val != null) && val.type === Buffer) {
        data[key] = new Buffer(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === Date) {
        data[key] = new Date(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === GeoPoint) {
        data[key] = new GeoPoint({
          lat: data[key].lat,
          lng: data[key].lng
        });
      }
    }
    return data;
  };


  /*
    Execute a ArangoDB command
   */

  ArangoDBConnector.prototype.execute = function(model, command) {
    var args, callback, context;
    args = [].slice.call(arguments, 2);
    callback = args[args.length - 1];
    context = {
      req: {
        command: command,
        params: args
      }
    };
    return this.notifyObserversAround('execute', context, (function(_this) {
      return function(context, done) {
        var bindVars, collection, q, query;
        if (_this.debug) {
          debug('ArangoDB: model=%s command=%s', model, command, args);
        }
        args[args.length - 1] = function(err, result) {
          if (err) {
            debug('Error: ', err);
          } else {
            context.res = result;
            debug('Result: ', result);
          }
          return done(err, result);
        };
        if (command === 'query') {
          query = context.req.params[0];
          bindVars = context.req.params[1];
          if (_this.debug) {
            if (typeof query.toAQL === 'function') {
              q = query.toAQL();
            } else {
              q = query;
            }
            debug("query: " + q + " bindVars: " + (JSON.stringify(bindVars)));
          }
          return _this.db.query.apply(_this.db, args);
        } else {
          collection = _this.getCollection(model);
          return collection[command].apply(collection, args);
        }
      };
    })(this), callback);
  };


  /*
    Checks the version of the ArangoDB
    @param callback [Function] The calback function, called with a (possible) error object and the server versio
   */

  ArangoDBConnector.prototype.getVersion = function(callback) {
    if (this.version != null) {
      return callback(null, this.version);
    } else {
      return this.api.get('version', function(err, result) {
        if (err) {
          callback(err);
        }
        this.version = result.body;
        return callback(null, this.version);
      });
    }
  };


  /*
    Create a new model instance for the given data
    @param model [String] The model name
    @param data [Object] The data to create
    @param callback [Function] The callback function, called with a (possible) error object and the created object's id
   */

  ArangoDBConnector.prototype.create = function(model, data, options, callback) {
    var fromName, fullIdName, id, idName, idValue, isEdge, toName;
    if (this.debug) {
      debug("create model " + model + " with data: " + (JSON.stringify(data)));
    }
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if ((idValue == null) || typeof idValue === 'undefined') {
      delete data[idName];
    } else {
      if (typeof idValue !== this.getDefaultIdType()) {
        id = this.getDefaultIdType()(idValue);
      }
      data._key = id;
      if (idName !== '_key') {
        delete data[idName];
      }
    }
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      data._from = data[fromName];
      if (fromName !== '_from') {
        delete data[fromName];
      }
      toName = this._toName(model);
      data._to = data[toName];
      if (toName !== '_to') {
        delete data[toName];
      }
    }
    return this.execute(model, 'save', data, (function(_this) {
      return function(err, result) {
        var fullIdValue, idType, modelClass, num;
        if (err) {
          if (err.errorNum === 1210) {
            err.message = '/duplicate/i';
          }
          return callback(err);
        }
        idValue = result._key;
        fullIdValue = result._id;
        modelClass = _this._models[model];
        idType = modelClass.properties[idName].type;
        if (idType === Number) {
          num = Number(idValue);
          if (!isNaN(num)) {
            idValue = num;
          }
        }
        delete data._key;
        data[idName] = idValue;
        if (isEdge) {
          if (fromName !== '_from') {
            data[fromName] = result._from;
          }
          if (toName !== '_to') {
            data[toName] = result._to;
          }
        }
        if (fullIdName) {
          data[fullIdName] = fullIdValue;
        }
        return callback(err, idValue);
      };
    })(this));
  };


  /*
    Update if the model instance exists with the same id or create a new instance
    @param model [String] The model name
    @param data [Object] The model instance data
    @param callback [Function] The callback function, called with a (possible) error object and updated or created object
   */

  ArangoDBConnector.prototype.updateOrCreate = function(model, data, options, callback) {
    var aql, bindVars, dataI, fromName, fullIdName, idName, idValue, isEdge, toName;
    if (this.debug) {
      debug("updateOrCreate for Model " + model + " with data: " + (JSON.stringify(data)));
    }
    this.getVersion(function(err, v) {
      var version;
      version = new RegExp(/[2-9]+\.[6-9]+\.[0-9]+/).test(v.version);
      if (err || !version) {
        err = new Error("Error updateOrCreate not supported for version {#v}");
        return callback(err);
      }
    });
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if (typeof idValue === 'number') {
      idValue = String(idValue);
    }
    delete data[idName];
    fullIdName = this._fullIdName(model);
    if (fullIdName === false) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      data._from = data[fromName];
      if (fromName !== '_from') {
        delete data[fromName];
      }
      toName = this._toName(model);
      data._to = data[toName];
      if (toName !== '_to') {
        delete data[toName];
      }
    }
    dataI = _.clone(data);
    dataI._key = idValue;
    aql = qb.upsert({
      _key: '@id'
    }).insert('@dataI').update('@data')["in"]('@@collection')["let"]('isNewInstance', qb.ref('OLD').then(false)["else"](true))["return"]({
      doc: 'NEW',
      isNewInstance: 'isNewInstance'
    });
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: idValue,
      dataI: dataI,
      data: data
    };
    return this.execute(model, 'query', aql, bindVars, (function(_this) {
      return function(err, result) {
        var isNewInstance, newDoc;
        if (result && result._result[0]) {
          newDoc = result._result[0].doc;
          delete newDoc._rev;
          if (fullIdName) {
            data[fullIdName] = newDoc._id;
            if (fullIdName !== '_id') {
              delete newDoc._id;
            }
          } else {
            delete newDoc._id;
          }
          if (isEdge) {
            if (fromName !== '_from') {
              data[fromName] = result._from;
            }
            if (toName !== '_to') {
              data[toName] = result._to;
            }
          }
          isNewInstance = {
            isNewInstance: result._result[0].isNewInstance
          };
          _this.setIdValue(model, data, newDoc._key);
          _this.setIdValue(model, newDoc, newDoc._key);
          if (idName !== '_key') {
            delete newDoc._key;
          }
        }
        return callback(err, newDoc, isNewInstance);
      };
    })(this));
  };


  /*
    Save the model instance for the given data
    @param model [String] The model name
    @param data [Object] The updated data to save or create
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.save = ArangoDBConnector.prototype.updateOrCreate;


  /*
    Check if a model instance exists by id
    @param model [String] The model name
    @param id [String] The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and an boolean value if the specified object existed (true) or not (false)
   */

  ArangoDBConnector.prototype.exists = function(model, id, options, callback) {
    if (this.debug) {
      debug("exists for " + model + " with id: " + id);
    }
    return this.find(model, id, options, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result.length > 0);
    });
  };


  /*
    Find a model instance by id
    @param model [String] model The model name
    @param id [String] id The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the found object
   */

  ArangoDBConnector.prototype.find = function(model, id, options, callback) {
    var command;
    if (this.debug) {
      debug("find for " + model + " with id: " + id);
    }
    command = 'document';
    if (this._isEdge(model)) {
      command = 'edge';
    }
    return this.execute(model, command, id, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result);
    });
  };


  /*
    Extracts where relevant information from the filter for a certain model
    @param [String] model The model name
    @param [Object] filter The filter object, also containing the where conditions
    @param [String] returnVariable The variable to build the where conditions on
    @return return [Object]
    @option return aqlArray [Array] The issued conditions as an array of AQL query builder objects
    @option return bindVars [Object] The variables, bound in the conditions
    @option return geoObject [Object] An query builder object containing possible parameters for a geo query
   */

  ArangoDBConnector.prototype._buildWhere = function(model, where, index) {
    var aqlArray, assignNewQueryVariable, bindVars, calculatedProps, condProp, condValue, fn, fromName, fullIdName, geoExpr, idName, toName, usedCalcProps;
    if (this.debug) {
      debug("Evaluating where object " + (JSON.stringify(where)) + " for Model " + model);
    }
    if ((where == null) || typeof where !== 'object') {
      return;
    }
    aqlArray = [];
    usedCalcProps = [];
    bindVars = {};
    geoExpr = {};
    index = index || 0;
    assignNewQueryVariable = function(value) {
      var partName;
      partName = 'param_' + (index++);
      bindVars[partName] = value;
      return '@' + partName;
    };
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    fromName = this._fromName(model);
    toName = this._toName(model);
    calculatedProps = this._calculatedProps(model);

    /*
      the where object comes in two flavors
    
       - where[prop] = value: this is short for "prop" equals "value"
       - where[prop][op] = value: this is the long version and stands for "prop" "op" "value"
     */
    fn = (function(_this) {
      return function() {
        var a, aql, c, collection, compareToPropValue, cond, condOp, lat, long, options, ref;
        if (condProp === idName) {
          condProp = '_key';
          if (typeof condValue === 'number') {
            condValue = String(condValue);
          }
        }
        if (condProp === fullIdName) {
          condProp = '_id';
        }
        if (condProp === fromName) {
          condProp = '_from';
        }
        if (condProp === toName) {
          condProp = '_to';
        }
        if (condProp === 'and' || condProp === 'or' || condProp === 'nor') {
          if (Array.isArray(condValue)) {
            aql = qb;
            for (c in condValue) {
              a = condValue[c];
              cond = _this._buildWhere(model, a, ++index);
              aql = aql[condProp](cond.aqlArray[0]);
              bindVars = merge(true, bindVars, cond.bindVars);
              usedCalcProps = merge(true, usedCalcProps, cond.usedCalcProps);
            }
            aqlArray.push(aql);
            aql = null;
          }
          return;
        }
        if (condValue && condValue.constructor.name === 'Object') {
          options = condValue.options;
          condOp = Object.keys(condValue)[0];
          condValue = condValue[condOp];
        }
        if (calculatedProps && calculatedProps[condProp]) {
          compareToPropValue = condProp;
          if (usedCalcProps.indexOf(condProp) === -1) {
            usedCalcProps.push(condProp);
          }
        } else {
          compareToPropValue = _this.returnVariable + "." + condProp;
        }
        if (condOp) {
          switch (false) {
            case condOp !== 'lte' && condOp !== 'lt' && condOp !== 'gte' && condOp !== 'gt' && condOp !== 'eq' && condOp !== 'neq':
              return aqlArray.push(qb[condOp](compareToPropValue, "" + (assignNewQueryVariable(condValue))));
            case condOp !== 'between':
              return aqlArray.push([qb.gte(compareToPropValue, "" + (assignNewQueryVariable(condValue[0]))), qb.lte(compareToPropValue, "" + (assignNewQueryVariable(condValue[1])))]);
            case condOp !== 'like':
              if (options === 'i') {
                options = true;
              } else {
                options = false;
              }
              return aqlArray.push(qb.fn('LIKE')(compareToPropValue, "" + (assignNewQueryVariable(condValue)), options));
            case condOp !== 'nlike':
              if (options === 'i') {
                options = true;
              } else {
                options = false;
              }
              return aqlArray.push(qb.not(qb.fn('LIKE')(compareToPropValue, "" + (assignNewQueryVariable(condValue)), options)));
            case condOp !== 'nin':
              return aqlArray.push(qb.not(qb["in"](compareToPropValue, "" + (assignNewQueryVariable(condValue)))));
            case condOp !== 'inq':
              condValue = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = condValue.length; i < len; i++) {
                  cond = condValue[i];
                  results.push(cond.toString());
                }
                return results;
              })();
              return aqlArray.push(qb["in"](compareToPropValue, "" + (assignNewQueryVariable(condValue))));
            case condOp !== 'near':
              ref = condValue.split(','), lat = ref[0], long = ref[1];
              collection = _this.getCollectionName(model);
              if (where.limit != null) {
                return geoExpr = qb.NEAR(collection, lat, long, where.limit);
              } else {
                return geoExpr = qb.NEAR(collection, lat, long);
              }
              break;
            default:
              return console.warn('No matching operator for : ', condOp);
          }
        } else {
          return aqlArray.push(qb.eq(compareToPropValue, "" + (assignNewQueryVariable(condValue))));
        }
      };
    })(this);
    for (condProp in where) {
      condValue = where[condProp];
      fn();
    }
    return {
      aqlArray: aqlArray,
      bindVars: bindVars,
      geoExpr: geoExpr,
      usedCalcProps: usedCalcProps
    };
  };


  /*
    Find matching model instances by the filter
    @param [String] model The model name
    @param [Object] filter The filter
    @param options [Object]
    @param [Function] callback Callback with (possible) error object or list of objects
   */

  ArangoDBConnector.prototype.all = function(model, filter, options, callback) {
    var addCalcPropertyToAql, aql, bindVars, calcProp, calcProps, field, fields, from, fromName, fullId, fullIdName, i, id, idName, indexFromName, indexFullId, indexId, indexToName, j, k, l, len, len1, len2, len3, m, order, ref, ref1, ref2, sortOrder, to, toName, usedCalcProps, w, where;
    if (this.debug) {
      debug("all for " + model + " with filter " + (JSON.stringify(filter)));
    }
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    fromName = this._fromName(model);
    toName = this._toName(model);
    calcProps = this._calculatedProps(model);
    usedCalcProps = {};
    bindVars = {
      '@collection': this.getCollectionName(model)
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    addCalcPropertyToAql = (function(_this) {
      return function(prop) {
        var aqlFormula;
        if (usedCalcProps[prop]) {
          return;
        }
        aqlFormula = calcProps[prop];
        aqlFormula = aqlFormula.replace("${returnVariable}", _this.returnVariable);
        aql = aql["let"](prop, new qbTypes.RawExpression(aqlFormula));
        if (!usedCalcProps) {
          usedCalcProps = {};
        }
        return usedCalcProps[prop] = prop;
      };
    })(this);
    if (filter.where) {
      if (filter.where[idName]) {
        id = filter.where[idName];
        delete filter.where[idName];
        if (typeof id === 'number') {
          id = String(id);
        }
        filter.where._key = id;
      }
      if (filter.where[fullIdName]) {
        fullId = filter.where[fullIdName];
        delete filter.where[fullIdName];
        filter.where._id = fullId;
      }
      if (filter.where[fromName]) {
        from = filter.where[fromName];
        delete filter.where[fromName];
        filter.where._from = from;
      }
      if (filter.where[toName]) {
        to = filter.where[toName];
        delete filter.where[toName];
        filter.where._to = to;
      }
      where = this._buildWhere(model, filter.where);
      ref = where.usedCalcProps;
      for (i = 0, len = ref.length; i < len; i++) {
        calcProp = ref[i];
        addCalcPropertyToAql(calcProp);
      }
      ref1 = where.aqlArray;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        w = ref1[j];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    if (filter.order) {
      if (typeof filter.order === 'string') {
        filter.order = filter.order.split(',');
      }
      ref2 = filter.order;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        order = ref2[k];
        m = order.match(/\s+(A|DE)SC$/);
        field = order.replace(/\s+(A|DE)SC$/, '').trim();
        if (field === idName || field === fullIdName || field === fromName || field === toName) {
          switch (field) {
            case idName:
              field = '_key';
              break;
            case fullIdName:
              field = '_id';
              break;
            case fromName:
              field = '_from';
              break;
            case toName:
              field = '_to';
          }
        }
        sortOrder = 'ASC';
        if (m && m[1] === 'DE') {
          sortOrder = 'DESC';
        }
        if (calcProps[field]) {
          addCalcPropertyToAql(field);
          aql = aql.sort(field, sortOrder);
        } else {
          aql = aql.sort(this.returnVariable + '.' + field, sortOrder);
        }
      }
    } else if (!this.settings.disableDefaultSortByKey) {
      aql = aql.sort(this.returnVariable + '._key');
    }
    if (filter.limit) {
      aql = aql.limit(filter.skip, filter.limit);
    }
    fields = _.clone(filter.fields);
    if (fields) {
      indexId = fields.indexOf(idName);
      if (indexId !== -1) {
        fields[indexId] = '_key';
      }
      indexFullId = fields.indexOf(fullIdName);
      if (indexFullId !== -1) {
        fields[indexFullId] = '_id';
      }
      indexFromName = fields.indexOf(fromName);
      if (indexFromName !== -1) {
        fields[indexFromName] = '_from';
      }
      indexToName = fields.indexOf(toName);
      if (indexToName !== -1) {
        fields[indexToName] = '_to';
      }
      for (l = 0, len3 = fields.length; l < len3; l++) {
        field = fields[l];
        if (calcProps[field]) {
          addCalcPropertyToAql(field);
        }
      }
      fields = (function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = fields.length; n < len4; n++) {
          field = fields[n];
          results.push('"' + field + '"');
        }
        return results;
      })();
      aql = aql["return"](qb.fn('KEEP')(qb.fn("MERGE")(this.returnVariable, usedCalcProps), fields));
    } else {
      aql = aql["return"](qb.fn('UNSET')(qb.fn("MERGE")(this.returnVariable, usedCalcProps), ['"_rev"']));
    }
    return this.execute(model, 'query', aql, bindVars, (function(_this) {
      return function(err, cursor) {
        var cursorToArray;
        if (err) {
          return callback(err);
        }
        cursorToArray = function(r) {
          if (_fieldIncluded(filter.fields, idName)) {
            _this.setIdValue(model, r, r._key);
          }
          if (idName !== '_key') {
            delete r._key;
          }
          if (fullIdName) {
            if (_fieldIncluded(filter.fields, fullIdName)) {
              _this._setFieldValue(r, fullIdName, r._id);
            }
            if (fullIdName !== '_id' && idName !== '_id') {
              delete r._id;
            }
          } else {
            if (idName !== '_id') {
              delete r._id;
            }
          }
          if (_this._isEdge(model)) {
            if (_fieldIncluded(filter.fields, fromName)) {
              _this._setFieldValue(r, fromName, r._from);
            }
            if (fromName !== '_from') {
              delete r._from;
            }
            if (_fieldIncluded(filter.fields, toName)) {
              _this._setFieldValue(r, toName, r._to);
              if (toName !== '_to') {
                delete r._to;
              }
            }
          }
          return r = _this.fromDatabase(model, r);
        };
        return cursor.map(cursorToArray, function(err, result) {
          if (err) {
            return callback(err);
          }
          if (filter.include != null) {
            return _this._models[model].model.include(result, filter.include, options, callback);
          } else {
            return callback(null, result);
          }
        });
      };
    })(this));
  };


  /*
    Delete a model instance by id
    @param model [String] model The model name
    @param id [String] id The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.destroy = function(model, id, options, callback) {
    if (this.debug) {
      debug("delete for " + model + " with id " + id);
    }
    return this.execute(model, 'remove', id, function(err, result) {
      if (err && err.errorNum === 1202) {
        err = null;
      }
      return callback && callback(err, {
        count: result && !result.error ? 1 : 0
      });
    });
  };


  /*
    Delete all instances for the given model
    @param [String] model The model name
    @param [Object] [where] The filter for where
    @param options [Object]
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.destroyAll = function(model, where, options, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("destroyAll for " + model + " with where " + (JSON.stringify(where)));
    }
    if (!callback && typeof where === 'function') {
      callback = where;
      where = void 0;
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.remove(this.returnVariable)["in"]('@@collection');
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      return callback && callback(err, {
        count: result.extra.stats.writesExecuted
      });
    });
  };


  /*
    Count the number of instances for the given model
    @param [String] model The model name
    @param [Function] callback Callback with (possible) error object or the number of affected objects
    @param [Object] where The filter for where
   */

  ArangoDBConnector.prototype.count = function(model, where, options, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("count for " + model + " with where " + (JSON.stringify(where)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = qb["let"]('count', aql["return"](this.returnVariable))["return"](qb.LENGTH('count'));
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      return callback(err, result._result[0]);
    });
  };


  /*
    Update properties for the model instance data
    @param [String] model The model name
    @param [String] id The models id
    @param [Object] data The model data
    @param [Object] options
    @param [Function] callback Callback with (possible) error object or the updated object
   */

  ArangoDBConnector.prototype.updateAttributes = function(model, id, data, options, callback) {
    var fromName, fullIdName, idName, isEdge, toName;
    if (this.debug) {
      debug("updateAttributes for " + model + " with id " + id + " and data " + (JSON.stringify(data)));
    }
    if (id === Number) {
      id = String(id);
    }
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      delete data[fromName];
      toName = this._toName(model);
      delete data[toName];
    }
    return this.execute(model, 'update', id, data, options, (function(_this) {
      return function(err, result) {
        var fullIdValue;
        if (result) {
          delete result['_rev'];
          _this.setIdValue(model, result, id);
          if (idName !== '_key') {
            delete result._key;
          }
          if (fullIdName) {
            fullIdValue = result._id;
            delete result._id;
            result[fullIdName] = fullIdValue;
          }
          if (isEdge) {
            result[fromName] = result._from;
            result[toName] = result._to;
          }
        }
        return callback && callback(err, result);
      };
    })(this));
  };


  /*
    Update matching instance
    @param [String] model The model name
    @param [Object] where The search criteria
    @param [Object] data The property/value pairs to be updated
    @param [Object] options
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.update = function(model, where, data, options, callback) {
    var aql, bindVars, collection, fromName, fullIdName, i, idName, len, ref, toName, w;
    if (this.debug) {
      debug("updateAll for " + model + " with where " + (JSON.stringify(where)) + " and data " + (JSON.stringify(data)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection,
      data: data
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (where) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.update(this.returnVariable)["with"]('@data')["in"]('@@collection');
    idName = this.idName(model);
    delete data[idName];
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    if (this._isEdge(model)) {
      fromName = this._fromName(model);
      delete data[fromName];
      toName = this._toName(model);
      delete data[toName];
    }
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, {
        count: result.extra.stats.writesExecuted
      });
    });
  };


  /*
    Update all matching instances
   */

  ArangoDBConnector.prototype.updateAll = ArangoDBConnector.prototype.update;


  /*
    Perform autoupdate for the given models. It basically calls ensureIndex
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.autoupdate = function(models, cb) {
    if (this.db) {
      if (this.debug) {
        debug('autoupdate for model %s', models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.each(models, ((function(_this) {
        return function(model, modelCallback) {
          var index, indexList, indexName, indexes, options, propIdx, property, ref;
          indexes = _this._models[model].settings.indexes || [];
          indexList = [];
          index = {};
          options = {};
          if (typeof indexes === 'object') {
            for (indexName in indexes) {
              index = indexes[indexName];
              if (index.keys) {
                options = index.options || {};
                options.name = options.name || indexName;
                index.options = options;
              } else {
                options = {
                  name: indexName
                };
                index = {
                  keys: index,
                  options: options
                };
              }
              indexList.push(index);
            }
          } else if (Array.isArray(indexes)) {
            indexList = indexList.concat(indexes);
          }
          ref = _this._models[model].properties;
          for (propIdx in ref) {
            property = ref[propIdx];
            if (property.index) {
              index = {};
              index[propIdx] = 1;
              if (typeof property.index === 'object') {
                if (typeof property.index.arangodb === 'object') {
                  options = property.index.arangodb;
                  index[propIdx] = options.kind || 1;
                  if (property.index.uniqe === true) {
                    options.unique = true;
                  }
                } else {
                  options = property.index;
                }
                if (options.background === void 0) {
                  options.background = true;
                }
              } else {
                options = {
                  background: true
                };
                if (property.unique) {
                  options.unique = true;
                }
              }
              indexList.push({
                keys: index,
                options: options
              });
            }
          }
          if (_this.debug) {
            debug('create indexes');
          }
          return async.each(indexList, (function(index, indexCallback) {
            var collection;
            if (_this.debug) {
              debug('createIndex: %s', index);
            }
            collection = _this.getCollection(model);
            return collection.createIndex(index.fields || index.keys, index.options, indexCallback);
          }), modelCallback);
        };
      })(this)), cb);
    } else {
      return this.dataSource.once('connected', function() {
        return this.autoupdate(models, cb);
      });
    }
  };


  /*
    Perform automigrate for the given models. It drops the corresponding collections and calls ensureIndex
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.automigrate = function(models, cb) {
    if (this.db) {
      if (this.debug) {
        debug("automigrate for model " + models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.eachSeries(models, ((function(_this) {
        return function(model, modelCallback) {
          var collection, collectionName;
          collectionName = _this.getCollectionName(model);
          debug('drop collection %s for model %s', collectionName, model);
          collection = _this.getCollection(model);
          return collection.drop(function(err) {
            if (err) {
              if (err.response.body != null) {
                err = err.response.body;
                if (!(err.error === true && err.errorNum === 1203 && err.errorMessage === 'unknown collection \'' + model + '\'')) {
                  return modelCallback(err);
                }
              }
            }
            debug('create collection %s for model %s', collectionName, model);
            return collection.create(modelCallback);
          });
        };
      })(this)), ((function(_this) {
        return function(err) {
          return cb && cb(err);
          return _this.autoupdate(models, cb);
        };
      })(this)));
    } else {
      return this.dataSource.once('connected', function() {
        return this.automigrate(models(cb));
      });
    }
  };

  return ArangoDBConnector;

})(Connector);

ArangoDBConnector.collection = 'collection';

ArangoDBConnector.edgeCollection = 'edgeCollection';

exports.ArangoDBConnector = ArangoDBConnector;
